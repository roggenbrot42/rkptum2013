\section{System Call Hooking}
\label{sec:syscallHooking}
A system call is a method to request a service from the kernel while being in user space. It provides an essential interface between user space processes and the operating system.\\
In Linux, all the syscall functions are declared in \verb+/linux/syscalls.h+. The address to these functions are stored in an array called \verb+sys\_call\_table+. 
A simple way to hook the provided services from the kernel, is to replace the address appropriate location in \verb+sys\_call\_table+. The address of the \verb+sys\_call\_table+ can be found in the system map file (\verb+/boot/System.map-\$(uname -r)+), which is a symbol table, used by the linux kernel. But the type of the symbol \verb+sys\_call\_table+ is read-only data (R). That means, we should remove the write protection mechanism before system call hooking.\\
On x86-64 microprocessors, there are a series of control registers to control the general CPU behavior. The \texttt{CR0} register stores 64 bits control flags for basic operations. The bit 16 (WP) determines, whether the CPU can write to read-only marked data. Hence, in order to disable the write protection, we just need to write 1 to the 16th bit in the \texttt{CR0} register using the kernel function \verb+read\_cr0+ and \verb+write\_cr0+ (defined in \verb+asm/paravirt.h+). The implementation can be found in \verb+hooking.h+.\\
To see which system calls a program used, you can use a debugging tool called \texttt{strace}. Then one can try to change the kernel service by hooking any syscall functions with the mechanism introduced above. One need to store the origin syscall function pointer, so that it is possible to recover the kernel service by unloading your rootkit module. 
