\section{Command and Control}
The command and control code parses all input over stdin for possible user 
commands. To do so, it hooks the \texttt{read} system call and filters for the 
stdin file descriptor. Because many users can write to this file descriptor at 
the same time, the code holds a \verb+taskinput_buffer+ struct for each task in 
a list. We decided to identify these input buffers by the name of the first 
file in the list of open file descriptors of the current process. 
This could be simplified by just using the process' ID.
Tests have shown that the autocompletion used by bash causes filename to be 
\texttt{NULL}, which is why autocompleted commands do not work.\par
The \verb+taskinput_buffer+ struct contains a pointer to the current location 
in the buffer, so the program can react appropriately if the user hits 
backspace or presses enter.\par
To actually parse the commands, the rootkit holds a list of all known commands. 
This list comprises of instances of the following structure:
\lstset{escapechar=,style=customc}
\begin{lstlisting}
struct command{
	char name[CMDLEN];
	size_t namelen;
	u64 hashcode;
	enum arg_t arg_type;
	void * handler;
	struct list_head list;
}
\end{lstlisting}
