\section{Function Hijacking}
There are many cases in which the method above is insufficient for hooking a 
function. It only works when the functions address is used indirectly using a 
call table like the \verb+sys_call_table+ or a handler variable. Even then, it 
is not always possible to successfully hook a function by replacing the address 
in some memory location. This might be the case if the target function's 
address is stored at multiple locations that are not clear or accessible when 
the hooking is to take place.\par
To remedy these problems, we place two trampoline assembly instructions at the 
beginning of the target function.
\lstset{style=customasm}
\begin{lstlisting}
 push $AbsoluteAddress
 ret
\end{lstlisting}
This of course requires the write protection to be turned off for that 
particular piece of memory. We chose to do it this way because the alternative 
was:
\begin{lstlisting}
 mov %rax, $AbsoluteAddress
 jmp %rax
\end{lstlisting}
The disadvantages become obvious immediately: although having the same number 
of instructions, this combination consumes seven instead of six bytes and 
purges the content of a register. This leads to potentially 
buggy code, and is therefore unacceptable.\newline

In our implementation we stored the hijacking code in a six byte array, with 
four zero-bytes as placeholder for the address.
\lstset{style=customc}
\begin{lstlisting}
 static char hjc[HIJACK_LEN] = {0x68,0x0,0x0,0x0,0x0,0xc3};
\end{lstlisting}
A second six byte array is used to save the content of the memory at the 
target's entry point so it is possible to restore the original function.
This is a desirable functionality, because we want the rootkit to be removable 
without crashing the system afterwards. Also, the original function will not be 
replaced by a new function, so, in most cases, we need to be able to use it for 
our own purposes at any given time.\par
\begin{figure}
\centering
 \includegraphics{control_flow}
 \caption{Typical function hijacking control flow}
\end{figure}
